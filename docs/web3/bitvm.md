---
title: BitVM
sidebarDepth: 0
---
[[toc]]
# BitVM

## BitVM是什么
:::tip BitVM
BitVM 是一种利用 Bitcoin Script + 链下计算，实现通用计算的交互式验证协议，同时也是一个“链下执行 + 链上验证”的计算模型
:::

## BitVM1
:::tip BitVM1
BitVM1 是 BitVM 系列的探索性早期版本，验证了通过链下计算 + 上链验证机制（类似 Optimistic Rollups）可实现比特币上的“图灵完备”合约。
BitVM1 = 交互式验证协议 + 链下执行 + 链上最小验证模型

链下执行：
Prover（证明者）在链下执行复杂程序（比如 SNARK 或 RISC-V 指令级模拟），生成执行结果并提交哈希承诺（对结果进行一次不可逆的哈希）到链上。

链上验证：
1. 如果没有人挑战，提交的结果直接生效。
2. 如果 Verifier（验证者）质疑结果，就触发 交互式二分查找：
   - Verifier 指定执行中的某一步，Prover 反馈对应输入/输出
   - 链上 Bitcoin Script 验证，逐步缩小到错误指令
:::
### BitVM1局限性
:::tip 
1. 单一验证者：只能有一个 Verifier；若其不配合，协议卡死，缺乏开放性
2. 挑战效率低：交互式二分查找，程序长时可能需要上千次交互，挑战耗时数周
3. 链上开销高：每次交互都要链上交易，交易数量多、脚本复杂，手续费高
4. 脚本复杂度大：程序需转换为 RISC-V 电路形式，部署在 Bitcoin Script 上不现实

BitVM1 证明了理论可行性，但受限于单一验证者、交互冗长、链上成本高等问题，属于实验性质
:::

## BitVM2
:::tip BitVM2
`Taproot` 是比特币的一项协议升级（BIP 341/342），它本身不是计算模型，而是提供了增强的签名、隐私和条件执行能力，使BitVM 等协议能够在比特币上更高效地实现复杂逻辑。

BitVM2 是 BitVM 系列的第二代版本，主要用到了`Taproot`、比特币脚本、哈希承诺，对于 BitVM1 的单一 Verifier、交互冗长、链上开销高、实用性低等问题分别进行了解决：
1. 通过引入多验证者机制，任何人都可以成为验证者。
2. 不再使用 BitVM1 的二分查找逐条指令挑战，而是提前提交`函数输入/输出和承诺哈希`，链上只验证关键节点，大幅降低链上交互次数
3. 只需要提交`函数输入输出和承诺哈希`，而不是每条指令，减少 Bitcoin Script 的复杂度和交易数量，降低了链上开销。
4. 优化断言机制，通过 Kickoff → Assert Initial → Assert Commit → Assert Final 的分段提交，将Assert Commit中间状态拆分，并行处理 + 输入/输出承诺，不需要像 BitVM1 那样一条条指令链上挑战，大幅提升效率。

BitVM2 = 交互式验证协议 + 链下执行 + 链上最小验证模型 + 多验证者机制

阶段说明:
1. Kickoff-1：申请报销，开启公示期（任何人可质疑）。
2. Kickoff-2：登记起点 & 时间（确定报销的考察区间）。
3. Assert Initial：提交“初始凭证”（说明我要从哪开始证明）。
4. Assert Commit_1/2：分段提交报销材料（中间账单），大家可以核对。
5. Assert Final：提交最终总账单，完成整个轨迹。
6. Disprove：如果有人质疑，链上展开挑战裁决，开始进入挑战验证。
:::

## BitVM2的入金地址是怎么生成的
:::tip
BitVM2 的核心是一个 `Taproot` 地址，背后挂着一个复杂的花费条件（script tree）。换句话说，入金地址就是对一整套“资金在什么情况下能花费”的规则的承载。这个脚本里面包含了：
1. Broker / Operator 的资金控制逻辑
2. Attester 的断言与惩罚逻辑
3. Watcher 未来可能触发的 challenge 路径
:::

### 用户发起deposit
:::tip
Broker接收用户的跨链请求（例如从链 A → 链 B 转账）。将这些请求打包，交给 Attester 来验证并签名。
:::

### pre sign
:::tip
在资金进入之前，Broker 和 Attester 需要先完成 pre-sign，pre-sign 包含所有可能的状态转移、惩罚交易、超时退款路径，一旦 pre-sign 完成，大家把所有必要的交易签好，才能最终确认入金地址。

把所有签名路径和预签好的交易对应的脚本，打包到一个 `Taproot Merkle Tree` 里，最终生成一个 `Taproot Srcipt/P2TR`地址，这个地址就对应此次交易唯一的 入金地址。
:::

### 用户入金
:::tip
用户向生成的 `Taproot` 地址打款，资金就进入了桥的托管状态，后续所有的资金流出（提现、惩罚、退款）都必须通过 pre-signed 的逻辑来执行。
:::


