---
title: 4、HTTP协议
sidebarDepth: 0
---
[[toc]]
# 4、HTTP协议
## HTTP
### HTTP/0.9
::: tip HTTP 0.9
- 只有一个命令`get`
- 没有header等描述数据的信息
- 服务器发送完毕，就关闭`TCP`连接（短连接）
:::
### HTTP/1.0
::: tip HTTP 1.0
- 增加了如`POST,PUT,DELETE`等的请求
- 增加了`status code`和`header`
- 多字符集支持、多部分发送、权限、缓存
:::
### HTTP/1.1
::: tip HTTP 1.1
支持长连接（`Connection:keep-alive`，一个`TCP`链接可以发送多个请求，默认开启），有“队头阻塞”的缺陷：一个请求响应完才能发送下一个。
`pipeline` 管线化技术（允许在第一个应答被发送之前就发送第二个请求，降低了通讯延迟）。解决了队头阻塞的问题。（默认关闭）但 `pipeling` 要求返回是按序的，如果前一个请求很耗时，那么后面的请求即使服务器处理完成，仍会等待前面的请求处理完成才能返回；
增加`host`，完善`HTTP`缓存
:::
### HTTP2.0
::: tip HTTP 2.0
- 头部压缩
- 服务器推送（只有HTTPS的网站才能使用）
- 多路复用（所有帧都采用二进制编码）
  - HTTP2.0的中，有两个重要的概念：`帧`和`流`;
  `帧`代表着最小的数据单位，每个`帧`都会标识该`帧`属于哪个流。多个`帧`组成一个数据流

多路复用就是在一个`TCP`链接中和可以存在多条流同时传输。换句话说 也就是一个`TCP`链接可以并行交错的发送请求和响应，这些请求和响应之间互不影响。另一端根据流的标识符和首部将他们重新组装起来;
- 同域名下所有通信都在单个连接上完成，消除了因多个 `TCP` 连接而带来的延时和内存消耗。
- 单个连接上可以并行交错的请求和响应，之间互不干扰
:::
## URI和URL
>- `URI`是统一资源标识符
>- `URL`是统一资源定位符。
>
>*区别*
>- `URI`：用字符串标识某一互联网资源，而`URL`：用来标识某一网页资源，可以理解为`URL`是`URI`的某种资源的具体表现形式，是`URI`的子集。
## HTTP和TCP/IP协议族
>网络是在`TCP/IP`协议族的基础上运作的，而`HTTP`协议只是其中的一个子集。`HTTP`协议和`TCP/IP`协议族内的其他众多的协议相同，用于客户端和服务器端之前的通信。

## TCP协议
>`TCP`协议是一个基于连接的采用流模式来传输数据的可靠（保证数据的正确性和顺序）性传输协议。（谷歌浏览器的`TCP`链接最多并发6个）
## TCP/IP协议族分层管理
>层次的划分有助于模块化，只需要把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。某一部分修改了就只需要改动修改的那个模块就好，
### 应用层
>应用层是大多数普通与网路相关的程序为了通过网络与其他程序通信所使用的层。每一个应用层的协议一般都会使用到传输层协议`TCP`和`UDP`协议之一。`TCP`能够确认数据最终是否送达对方：
>- 运行在`TCP`协议上的协议：
>   - `HTTP`（80端口）：用于浏览网页
>   - `HTTPS`（443端口）：比`HTTP`更安全
>   - `FTP`（20和21端口）：用于传输文件
>   - `POP3`（25端口）：用于收邮件
>   - `SSH`（22端口）：用于加密安全登录用
>- 运行在`UDP`协议上的协议：
>   - `DCHP`（67端口）：动态配置`IP`协议
### 传输层
>传输层提供了网络连接中的两台计算机之间的数据传输。`TCP`和`UDP`都是传输层的协议。
### 网络层
>网络层起的作用就是在众多的选项内选择一条传输路线。`IP`协议是网络层的协议
### 数据链路层
>用来处理连接网络的硬件部分。包括控制操作系统、硬件设备驱动，光纤等物理可见部分，硬件上的范畴均在链路层的作用范围
## TCP连接的建立与释放
### TCP的三次握手
::: tip 三次握手
为了准确无误的将数据送达目标处，`TCP`协议采用了三次握手的策略；
例子：客户端：我准备好了，你准备好了么，收到请回答？
服务端：我收到了，我也准备好了，你收到了么？
客户端：我也收到了
*作用*
- 1、让对方知道自己的发送能力和接受能力都是OK的。
- 2、指定自己的初始化`ISN`序列号，为后面的可靠传送做准备
- 3、如果是`HTTPS`协议，三次握手还会进行数字证书验证和加密密匙的生成；

三次握手的首要目的就是`同步序列号`。只有同步了序列号才有可靠的传输，`TCP`协议的许多特性都是依赖序列号实现的，比如流量控制、消息丢失后重发等等，这也是三次握手中的报文被称为`SYN（Synchronize Sequence Numbers）`的原因，

`Sequence Number`是包的序号，用来解决网络包乱序的问题。
`Synchronize Sequence Numbers`就是`SYN`
`Ackonwledgement Number`就是`ACK`，用于确认收到，用来解决不丢报的问题


<img :src="$withBase('/assets/browser-4-1.png')" alt="browser-4-1">

在socket编程中，客户端执行`connect()`时，将触发三次握手。

发送第一个`SYN`的一端将执行主动打开（`active open`），接收这个`SYN`并发回下一个`SYN`的另一端执行被动打开
:::

### 半链接队列
::: tip
服务器第一次收到客户端的`SYN`之后，就会处于`SYN-RCVD`状态，此时双方还未建立链接，服务器会把此种状态下的请求链接放在一个队列里，我们把这种队列称之为半链接队列。

当然还有全连接队列：已经完成三次握手，建立起链接的就会放在全连接队列中。如果队列满了就有可能出现丢包现象。
:::

### `ISN` 是固定的么？
>三次握手的一个重要功能是客户端和服务端交换`ISN(Initial Sequence Number)`，以便让对方知道接下来的接收数据的时候如何按序列号组装数据。如果`ISN`是固定的，很容易被攻击者猜到后续的确认号，因此`ISN`是动态生成的；

### 第三次握手失败这怎么办
>当第三次握手失败时，服务器并不会重传`ACK`报文，而是直接发送`RST`报文段，进入`CLOSED`状态。这样做的目的是为了防止`SYN`洪泛攻击；

### TCP的四次挥手
::: tip 四次挥手
客户端：我要关闭了（主动关闭），你收到了么？
服务器：我收到了，开始关闭了，关闭好了我再告诉你！
……
服务器：我已经关闭（被动关闭）了，你收到了么？
客户端：我收到了

为什么关闭要4步？

因为服务端的`listen`状态下的`socket`当收到客户端建立连接请求的`SYN`报文后，它可以把`ACK`和`SYN`（`ACK`起应答作 用而`SYN`起同步作用）放在一个报文里来发送。但是关闭链接时，当服务器接到客户端的`FIN`报文通知时服务器只能发一个回应报文，然后通知应用程序开始关闭，应用程序完成全部数据发送并确定可以终止时，服务器才会发送`FIN`告诉客户端可以真正断开连接了。所以这一步`ACK`报文和`FIN`报文需要分开发送，因此多了一个环节。

`TCP`是全双工信道，何为双工就是客户端和服务端建立两条通道：
- 通道1：客户端的输出链接服务器端的输入；
- 通道2：客户端的输入链接服务器端的输出；

两个通道可以同时工作，所以关闭双通道时需要双方各自关闭；

客户端：我要关闭输出通道了。
服务端：好的我知道了，我也要关闭输入通道了。
服务端：我也要关闭输出通道了。
客户端：好的，知道了，我也关闭输入通道了。
:::
## 不可靠的UDP协议
>`UDP`是无连接采用数据报模式来传输数据的不可靠的传输协议（不需要接收到反馈），对于大批量广播或者类似于寄信。

## HTTP与HTTPS的区别
::: tip
`https`协议需要ca证书，免费的证书很少
`http`协议是明文传输的，而`https`协议是通过`ssl`加密传输的安全性协议；
`http`与`https`连接方式不同，采用的端口号也不同；
`http`是无状态协议；`https`协议是通过`SSL+http`协议构建的可进行加密传输、身份认证的网络协议，比`http`安全；
:::
