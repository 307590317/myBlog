---
title: 4、HTTP协议
sidebarDepth: 0
---
[[toc]]
# 4、HTTP协议
## HTTP
### HTTP/0.9
::: tip HTTP 0.9
- 只有一个命令`get`
- 没有`header`等描述数据的信息
- 服务器发送完毕，就关闭`TCP`连接（短连接）
:::
### HTTP/1.0
::: tip HTTP 1.0
- 增加了如`POST,HEAD`的请求
- 增加了`status code`和`header`
- 传输的数据不仅限于文本，还可以传输图像、视频、二进制等
- 多字符集的支持（`Accept: */*`）、缓存管理
:::
### HTTP/1.1
::: tip HTTP 1.1
- 新增了如`PUT，PATCH，DELETE，OPTIONS`的请求
- 支持长连接（`Connection:keep-alive`，一个`TCP`链接可以发送多个请求，默认开启）
- `pipeline` 管线化技术（允许在第一个应答被发送之前就发送第二个请求，降低了通讯延迟）。（默认关闭）但 `pipeling` 要求返回是按序的，如果前一个请求响应很耗时（服务器处理慢或传输慢），那么后面的请求即使服务器处理完成，仍会等待前面的请求处理完成才能返回；，有“队头阻塞”的缺陷：一个请求 响应 完才能发送下一个。
- 增加`host`，完善`HTTP`缓存
:::

### HTTP2.0
::: tip HTTP 2.0（二进制协议）
- 头部压缩，使用`HPACK`算法对头部进行压缩
- 服务器推送（只有`HTTPS`的网站才能使用）
- 多路复用（所有帧都采用二进制编码）
  - 采用二进制帧和流的概念，允许在一个TCP连接中同时发送多个请求和响应。避免了1.1中的串行请求和响应，提高了并发性和资源利用率。
  - HTTP2.0的中，有两个重要的概念：`帧`和`流`;
  - `帧`代表着最小的数据单位，每个`帧`都会标识该`帧`属于哪个流。多个`帧`组成一个数据流
- 设置优先级，可以设置数据帧的优先级，让服务器先处理。

多路复用就是在一个`TCP`链接中和可以存在多条流同时传输。换句话说 也就是一个`TCP`链接可以并行交错的发送请求和响应，这些请求和响应之间互不影响。另一端根据流的标识符和首部将他们重新组装起来;
:::

## URI和URL
>- `URI`是统一资源标识符
>- `URL`是统一资源定位符。
>
>*区别*
>- `URI`：用字符串标识某一互联网资源，而`URL`：用来标识某一网页资源，可以理解为`URL`是`URI`的某种资源的具体表现形式，是`URI`的子集。
## HTTP和TCP/IP协议族
>网络是在`TCP/IP`协议族的基础上运作的，而`HTTP`协议只是其中的一个子集。`HTTP`协议和`TCP/IP`协议族内的其他众多的协议相同，用于客户端和服务器端之前的通信。

## TCP/IP协议族分层管理
>层次的划分有助于模块化，只需要把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。某一部分修改了就只需要改动修改的那个模块就好，
### 应用层
>应用层是大多数普通与网路相关的程序为了通过网络与其他程序通信所使用的层。每一个应用层的协议一般都会使用到传输层协议`TCP`和`UDP`协议之一。`TCP`能够确认数据最终是否送达对方：
>- 运行在`TCP`协议上的协议：
>   - `HTTP`（80端口）：用于浏览网页
>   - `HTTPS`（443端口）：比`HTTP`更安全
>   - `FTP`（20和21端口）：用于传输文件
>   - `POP3`（25端口）：用于收邮件
>   - `SSH`（22端口）：用于加密安全登录用
>- 运行在`UDP`协议上的协议：
>   - `DCHP`（67端口）：动态配置`IP`协议
### 传输层
>传输层提供了网络连接中的两台计算机之间的数据传输。`TCP`和`UDP`都是传输层的协议。
### 网络层
>网络层起的作用就是在众多的选项内选择一条传输路线。`IP`协议是网络层的协议
### 数据链路层
>用来处理连接网络的硬件部分。包括控制操作系统、硬件设备驱动，光纤等物理可见部分，硬件上的范畴均在链路层的作用范围

## TCP协议
::: tip TCP
`TCP`协议是一种基于连接的采用流模式来传输数据的、可靠的（保证数据的正确性和顺序）、基于IP的传输协议。（谷歌浏览器的`TCP`链接最多并发6个）

**特点**
- 1、在应用层，数据以字节流的形式通过TCP连接在应用层之间传输
- 2、TCP提供可靠的传输，保证数据的顺序和正确性。
- 3、TCP提供全双工通信

TCP相对于UDP的特点：面向连接的、字节流和可靠传输
:::
### TCP的三次握手
::: tip 三次握手
为了准确无误的将数据送达目标处，`TCP`协议采用了三次握手的策略；

1、客户端：我准备好了，你准备好了么，收到请回答？
2、服务端：我收到了，
3、我也准备好了，你收到了么？
4、客户端：我收到了
为了效率和性能，2、3两条消息可以合并为一条，所以只需要三次握手

*作用*
- 1、让对方知道自己的发送能力和接受能力都是OK的。
- 2、指定自己的初始化`ISN`序列号，为后面的可靠传送做准备
- 3、如果是`HTTPS`协议，三次握手还会进行数字证书验证和加密密匙的生成；

三次握手的首要目的就是`同步序列号`。只有同步了序列号才有可靠的传输，`TCP`协议的许多特性都是依赖序列号实现的，比如流量控制、消息丢失后重发等等，这也是三次握手中的报文被称为`SYN（Synchronize Sequence Numbers）`的原因，

6种TCP标志位
- 1、**`URG(紧急)`**：当 **`URG=1`**，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
- 2、**`PSH(推送)`**：当两个应用进程进行交互式通信时，有时在一端的应用进程希望再键入一个命令后立即就能收到对方的响应，这时候就将 **`PSH=1`**；
- 3、**`RST(复位)`**：当 **`RST=1`**，表明`TCP`连接中出现严重差错，必须释放连接，然后再重新建立连接；
- 4、**`ACK(Ackonwledgement Number)`**：确认收到上一条。仅当 **`ACK=1`** 时，确认号字段才有效。`TCP`规定，在连接建立后所有报文的传输都必须把`ACK`置1，解决不丢包问题；
- 5、**`SYN(Synchronize Sequence Numbers)`(SYN为1不能携带数据，但会消耗掉一个序号)**：表示建立连接。当`SYN=1，Seq=x(x：随机产生)`，表示建立链接报文，若同意连接，则响应报文中应该使`SYN=1，ACK=1(值为建立链接请求的Seq的值+1)`；
- 6、**`FIN(终止)`**：用来释放连接。当`FIN=1`，表明此报文的发送方的数据已经发送完毕，并且要求释放；

**`SYN`**用来请求连接，请求时`SYN=1`(`SYN`报文段)
**`ACK`**用来确认连接，请求时`ACK=1`(`ACK`报文段)
`ISN(seq:Sequence Number)`:是包的序号，相当于每一条消息的id，报文中用`seq`字段。`ACK=1`，表示确认收到上一条，`ack= seq + 1`，表示请对方发送下一条。用来解决网络包乱序的问题，

<img :src="$withBase('/assets/browser-4-1.png')" alt="browser-4-1">

第一次握手：客户端发送位码为`SYN＝1`，随机产生一个32位序号1234567，`seq=1234567`的数据包到服务器。客户端状态`CLOSED -> SYN_SENT`。

第二次握手：服务端收到请求后，由`SYN=1`知道，客户端要求建立联机，然后会以自己的`SYN`报文作为应答，确认号是 `ack = 1234568`，并且指定自己的初始化序列号`ISN(seq = 7654321)`，表示自己收到了客户端的`SYN`。服务端状态`LISTEN -> SYN_RCVD`。（服务端知道客户端 发送能力：OK）
在确认报文段中`SYN=1，ACK=1`，确认号`ack=1234568`，初始序号`seq=7654321`。

第三次握手：客户端收到后检查`ack`是否为第一次发送`seq`的值+1，以及位码`SYN`是否为1，若正确，会发送一个`ACK`报文，`ack = 7654322`(把服务器的`seq`的值+1)，表示已经收到了服务端的报文。客户端状态`SYN_SENT -> ESTABLISHED(已建立链接)`，（客户端知道服务端 发送、接受能力：OK）
服务端收到`ACK`报文后确认`ack`值与第二次握手发送的`seq`的值+1相同，服务端状态`SYN_RCVD -> ESTABLISHED`，连接建立成功；
确认报文段`AKC=1`，确认号`ack=7654322`，序号`seq=1234567+1(初始为1234567，第二个报文段所以需要+1)`

在socket编程中，客户端执行`connect()`时，将触发三次握手。

发送第一个`SYN`的一端将执行主动打开（`active open`），接收这个`SYN`并发回下一个`SYN`的另一端执行被动打开
:::

### 半链接队列
::: tip
服务器第一次收到客户端的`SYN`之后，就会处于`SYN-RCVD`状态，此时双方还未建立链接，服务器会把此种状态下的请求链接放在一个队列里，我们把这种队列称之为半链接队列。

当然还有全连接队列：已经完成三次握手，建立起链接的就会放在全连接队列中。如果队列满了就有可能出现丢包现象。
:::

### `ISN` 是固定的么？
>三次握手的一个重要功能是客户端和服务端交换`Sequence Number(缩写为ISN：Initial Sequence Number)`，以便让对方知道接下来的接收数据的时候如何按序列号组装数据。如果`ISN`是固定的，很容易被攻击者猜到后续的确认号，因此`ISN`是动态生成的；

### 第三次握手失败这怎么办
::: tip
当第三次握手失败时，服务器并不会重传`ACK`报文，而是直接发送`RST`报文段，进入`CLOSED`状态。这样做的目的是为了防止`SYN`洪泛攻击；

`SYN`洪泛攻击:
客户端在短时间内伪造大量不存在的IP地址，并向服务端不断的发送SYN包，服务端则回复确认包，并等待客户端确认，由于源地址不存在，因此服务端需要不断的重发直至超时。这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而丢弃，从而导致网络瘫痪。SYN攻击是一种典型的DOS/DDOS攻击。

如何解决`SYN`洪泛攻击
- 1、增加最大半连接数
- 2、缩短超时时间
:::

### TCP的四次挥手
::: tip 四次挥手
为什么关闭要4步？

因为服务端的`listen`状态下的`socket`当收到客户端建立连接请求的`SYN`报文后，它可以把`ACK`和`SYN`（`ACK`起应答作 用而`SYN`起同步作用）放在一个报文里来发送。但是关闭链接时，当服务器接到客户端的`FIN`报文通知时服务器只能先发一个`ACK`报文作为回应，因为此时可能还有数据在发送，不能马上发送`FIN`。全部数据发送并确定可以终止时，服务器才会发送`FIN`告诉客户端可以真正断开连接了。所以这一步`ACK`报文和`FIN`报文需要分开发送，因此多了一个环节。

`TCP`是全双工信道，何为双工就是客户端和服务端建立两条通道：
- 通道1：客户端的输出链接服务器端的输入；
- 通道2：客户端的输入链接服务器端的输出；

两个通道可以同时工作，所以关闭双通道时需要双方各自关闭；

关闭时并不是确认一次就立即关闭了，而是等待四次握手都完成，双方都收到对方的`ack`报文之后，并且等待2MSL之后，双方才会都释放连接。

四次挥手释放连接时，等待2MSL的意义？
1MSL是一个报文存在的最长时间。
- 1、为了保证客户端最后发送的`ACK`报文能够到达服务端。这个报文有可能丢失，导致服务端接收不到，此时服务端会重新发送`FIN`报文。接着客户端重传一次`ACK`
- 2、防止已失效链接的请求报文出现在本链接中，客户端在发送完一个`ACK`报文之后，再经过2MSL，就可以使本连接持续时间内所产生的所有报文段都 从网络中消失。
:::

## 不可靠的UDP协议
>`UDP`是无连接采用数据报模式来传输数据的不可靠的传输协议（不需要接收到反馈），对于大批量广播或者类似于寄信。

## HTTPS
::: tip HTTPS是什么？
`HTTPS协议`是在`HTTP协议`的基础上，增加了`SSL/TLS`协议，来加密数据包，增加数据的安全性。

**SSL/TLS的作用**
- 1、信息加密传播，保证安全性
- 2、具有签名校验机制，信息被篡改会被发现
- 3、配备证书，防止身份被冒充。

SSL是证书，对于https的协议，浏览器在建立TCP连接之后，会继续进行TSL的四次握手，来建立加密通信。

握手时，服务器收到客户端的请求后，会做以下操作：
- 1、会确认通信协议的版本，两端支持的版本不一致的话，服务端会关闭加密通信。
- 2、生成随机数，用于之后生成对话密钥。确认使用的加密方式。
- 3、向客户端发送服务器的证书（证书中包含公钥）。
:::
## SSL大致握手过程
::: tip
客户端发出加密通信请求`ClientHello`，并提供如下信息：
- 1、支持协议的版本
- 2、客户端生成的随机数`A`，用于后续生成对话秘钥
- 3、支持的加密方法。
- 4、支持的压缩方法

服务端收到请求后，向客户端发出回应：`SeverHello`，并提供如下信息：
- 1、确认使用的加密协议版本。若与客户端不一致，则服务端关闭加密通道
- 2、服务端生成的随机数`B`，用于后续生成对话秘钥
- 3、确认使用的加密方法，比如`RSA公钥加密`。
- 4、服务器证书。

客户端收到回应之后，首先验证证书是否可信、域名与实际域名是否一致、是否过期。如果没问题，就从证书中取出公钥。然后向服务器发送如下信息
- 1、一个用公钥加密后的随机数`C`
- 2、编码改变通知，表示随后的信息将用双方商定的加密方法和密钥发送。
- 3、客户端握手结束的通知。这一项同时也是前面发送所有内容的`hash`值,用来供服务器校验。

服务器收到之后的回应
- 1、编码改变通知，表示随后的信息将用双方商定的加密方法和密钥发送。
- 2、服务器握手结束通知。这一项同时也是前面发送所有内容的`hash`值,用来供客户端校验。
:::

## 加密方式
::: tip 对称加密
对称加密：意思是接受方和发送方都用同一个密钥，加密解密都是同一个密钥，最终只需要保存一个密钥就好。

**非对称加密**
非对称加密：发送方和接收方用的是一对密钥，即公钥和私钥。一般私钥都是保密的，放在服务端。公钥是在证书当中的，会发送给客户端。我们可以用公钥加密，私钥解密，也可用私钥加密公钥解密。

**两种方式优缺点**
对称加密 快，但是不安全，需要一端生成后传递给另一端，一旦被劫持，就不安全了。
非对称加密 速度比较慢，但是安全。不过如果用私钥加密，那么有公钥的人都能够解密。

`HTTPS`采用了混合加密的方式：用非对称加密方法加密随机数，用对称加密将三个随机数（其中一个随机数是解密后的）进行加密生成对话密钥，用来加密之后对话的整个过程。
- 1、建立TSL握手时，客户端会生成一个随机数`A`，传给服务端（明文），服务端也会生成一个随机数`B`，传给客户端（明文）(此时双方都有了两个明文的随机数)。
- 2、然后客户端再产生一个随机数`C`，然后用证书中的公钥加密随机数，发送给服务端。
- 3、服务端收到后用私钥解密，这样双方就有了三个随机数，然后双方用之前商定的对称加密方法各自生成本次会话所用的同一把会话密钥（session key）。

就算传输过程中会话密钥被劫持，没有私钥也是无法解密真正的会话密钥。
:::
## 防止数据被篡改
::: tip 数据篡改
为了防止数据被篡改，就需要用到 **`数字签名`**

**`数字签名`**：将原文（部分数据关键信息）先用Hash函数生成信息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接受者

客户端校验数字签名：
- 1、用证书中的公钥去解密数字签名得到消息摘要
- 2、用hash函数对收到的原文生成一个摘要信息。
- 3、对比两个信息，一致则说明数据没有被篡改
:::

## 防止证书被篡改
::: tip 证书篡改
客户端收到证书后，浏览器会对证书的颁发机构，有效期等信息进行校验，可用进行下一步
用CA证书中的公钥对发来的证书的签名做解密，解密之后得到摘要XX。
根据证书签名使用的`Hash`算法，计算出服务端证书的摘要YY,
对比XX和YY，结果一致代表证书可用

- 1、浏览器根据内置的根证书（浏览器内置各大CA机构的根证书），与服务器发来的证书的颁发机构做对比。是伪造的：浏览器不认识，直接认为是危险证书
- 2、证书颁发机构可信任，则从CA证书中找到公钥，对服务端的证书里的签名做解密。解密不了，认为是危险证书
- 3、签名可以解密后，得到证书的摘要XX。根据证书签名使用的Hash算法，计算出服务端证书的摘要YY
- 4、对比XX和YY，结果一致则代表证书可用。然后就可以用证书的公钥进行后续加密了。
:::

## HTTP与HTTPS的区别
::: tip
`https`协议需要ca证书，免费的证书很少
`http`协议是明文传输的，而`https`协议是通过`ssl`加密传输的安全性协议；
`http`与`https`连接方式不同，采用的端口号也不同；
`http`是无状态协议；`https`协议是通过`SSL+http`协议构建的可进行加密传输、身份认证的网络协议，比`http`安全；
:::
