---
title: Vue 响应式数据源码解析
sidebarDepth: 0
---

[[toc]]

# Vue 响应式数据源码解析

```html
<div id="app">
  {{name}}
</div>
<script>
  const vm = new Vue({
    el: "#app",
    data: {
      name: "mrzhao",
    },
  });
  setTimeout(() => {
    vm.name = "zhongguo";
  }, 1000);
</script>
```

::: tip Vue
Vue 的特点就是数据驱动视图，数据变化会导致视图自动更新。这样我们就不需要关心 DOM 操作了，只需要更改数据就可以了。Vue2 内部通过`defineProperty`方法实现了响应式的数据变化，接下来解析原理。
:::

## 数据的初始化

```js
// src/index.js

import { initMixin } from "./init";

// Vue2.0中 可以看出Vue就是一个构造函数
function Vue(options) {
  // 当用户new Vue时 就调用原型上的init方法进行vue的初始方法
  this._init(options);
}

// 为了利于代码维护，方便以后扩展，拆分逻辑到不同的文件中 模块化的概念

initMixin(Vue); // 在Vue原型上扩展初始化方法

export default Vue;
```

::: tip
为了方便维护、扩展，所以把不同的逻辑拆分到不同的文件里，通过 import 导入，有利于代码分割。
:::

```js
// src/init.js
import { initState } from "./state";

export function initMixin(Vue) {
  Vue.prototype._init = function(options) {
    const vm = this;
    // 实例上有个属性$options 表示的是用户传入的所有属性
    vm.$options = options;
    // 初始化状态
    initState(vm);
  };
}
```

```js
// src/state.js
import { observe } from "./observer/index";

// vue的数据 props、methods、data、compunted、watch都在这里初始化
export function initState(vm) {
  // 将所有数据都定义在 vm属性上，并且后续更改 需要触发视图更新
  // 拿到用户的参数
  const opts = vm.$options;
  // 初始化顺序如下 props -> methods -> data -> computed -> watch
  // if (opts.props) initProps(vm, opts.props)
  // if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    // 数据的初始化
    initData(vm);
  }
  // if (opts.computed) initComputed(vm, opts.computed)
  // if (opts.watch) initWatch(vm, opts.watch)
}

function initData(vm) {
  // 拿到用户传入的data
  let data = vm.$options.data;
  // 对data类型进行判断 如果是函数 获取函数返回值作为对象（data写成函数是为了防止数据在组件间共享）
  data = vm._data = typeof data === "function" ? data.call(vm) : data;

  // 将_data中的数据全部代理到vue实例(vm)上，取值时用this.name 代替 this._data.name
  for (let key in data) {
    proxy(vm, "_data", key);
  }

  // 观测数据，核心方法
  observe(data);
}

function proxy(vm, source, key) {
  Object.defineProperty(vm, key, {
    get() {
      return vm[source][key];
    },
    set(newValue) {
      vm[source][key] = newValue;
    },
  });
}
```
::: tip initState
对数据进行了代理，将传入的数据代理到了vue实例上，在页面中就可以用`this.xxx`来使用数据。此外还通过`observe`方法对数据进行了观测，目的是为了实现响应式的数据
:::

## Watcher 类的改造

```js
// src/observer/watcher.js
import { popTarget, pushTarget } from "./dep";
import { queueWatcher } from "./scheduler";

let id = 0;
class Watcher {
  constructor(vm, exprOrFn, cb, options) {
    // this.vm = vm;
    // this.exprOrFn = exprOrFn;
    this.user = !!options.user; // 是不是用户watcher
    // this.cb = cb;
    // this.options = options;
    // this.id = id++;
    // this.deps = [];
    // this.depsId = new Set();

    // watch可能写成字符串 比如 info.age
    if (typeof exprOrFn == "string") {
      this.getter = function() {
        // 当我数据取值时 ， 会进行依赖收集
        // info.age   vm['info']['age']
        let path = exprOrFn.split("."); // [info,age]
        let obj = vm;
        for (let i = 0; i < path.length; i++) {
          obj = obj[path[i]];
        }
        return obj;
      };
    } else {
      this.getter = exprOrFn; // updateComponent
    }

    // 首次需要取值
    this.value = this.get(); // 默认初始化 要取值
  }
  // get() {
  //   pushTarget(this); // Dep.target = watcher
  //   const value = this.getter.call(this.vm); // render() 方法会去vm上取值 vm._update(vm._render)
  //   popTarget(); // Dep.target = null; 如果Dep.target有值说明这个变量在模板中使用了

  //   return value;
  // }
  // update() {
  //   // vue中的更新操作是异步的
  //   queueWatcher(this); // 多次调用update 会将watcher缓存
  // }
  run() {
    let newValue = this.get();
    let oldValue = this.value;
    this.value = newValue; // 为了保证下一次更新时 上一次的最新值是下一次的老值
    // 用户的 watch
    if (this.user) {
      // 如果两次的值不相同  或者值是引用类型 因为引用类型新老值是相等的 他们是指向同一引用地址
      if (newVal !== oldVal || isObject(newVal)) {
        this.cb.call(this.vm, newVal, oldVal);
      }
    } else {
      // 渲染watcher
      this.cb.call(this.vm);
    }
  }
  // addDep(dep) {
  //   let id = dep.id;
  //   if (!this.depsId.has(id)) {
  //     this.depsId.add(id);
  //     this.deps.push(dep);
  //     dep.addSub(this);
  //   }
  // }
}

export default Watcher;
```

::: tip Watcher 改造
1、对用户`watcher(options.user = true)`传入的`exprOrFn`做了兼容处理，转换成去`vm`上取值的函数。并在初始化时调用拿到第一次的旧值保存到`watcher`的`value`属性上
2、在属性更新的时候会调用`run`方法，如果是用户`watcher`，执行用户回调`cb`的时候将老值和新值传过去，就行了
:::
