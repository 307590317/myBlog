---
title: JS基础面试题
sidebarDepth: 0
---
[[toc]]
# JS基础面试题

## `['1', '2', '10'].map(parseInt)`
::: tip
输出结果`[1,NaN,2]`
`parseInt(str,n)`
把第一个参数看作是一个数的`n`进制的表示，而返回的数值则是十进制；
如`parseInt('123',5);`将'123'当做5进制的数，返回十进制 `1 * 5^2 + 2 * 5^1 + 3 * 5^0 = 38`
如果第一个参数中不存在n进制的表示数字，则返回能解析的部分，`parseInt('15',2) = 1`
:::

## `setTimeout、Promise、async/await` 的区别
### `setTimeout`
`setTimeout`的回调函数是放到宏任务队列里;（等到执行栈清空后执行）
### `Promise`
>`Promise`本身执行时是同步的，`then`产生的回调函数是放到微任务队列里
### `async/await` 
>`async`函数表示函数里可能会有异步的方法，`await`后面跟一个表达式，`async`方法执行时，遇到`await`会立即执行`await`后面的表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行

## JS异步解决方案的发展历程以及优缺点
### 回调函数
::: tip
*优点*
- 1、解决了同步问题
 
*缺点*
- 缺乏顺序性：回调地域导致的调试困难
- 嵌套函数耦合性高；
- 嵌套过多很难处理错误
- 不能`return`
:::
### `Promise`
::: tip
*优点*
- 1、解决了回调地狱的问题

*缺点*
- 一旦开始就无法取消
- 不知道内部进行到哪个阶段
- 错误需要通过回调函数来捕获
:::
### `Async/await`
::: tip
终极的异步解决方案

*优点*
- 代码清晰，处理了地域回调的问题

*缺点*
- `await`将异步变同步，多个异步操作如果没有依赖关系，使用`await`会导致性能下降
:::



## `ES5/ES6` 的继承除了写法以外还有什么区别
::: tip 
*继承的机制不同*

- `ES5`：先生成子类的实例，再调用父类的构造函数修饰子类的实例，由于父类的内置属性无法获取，导致无法继承原生的构造函数。（比如，`Array`构造函数有一个内部属性`[[DefineOwnProperty]]`，用来定义新属性时，更新`length`属性，这个内部属性无法在子类获取，导致子类的`length`属性行为不正常。）
- `ES6`：先生成父类的实例，再调用子类的构造函数修饰生成的实例。由于这个差异，使得`ES6`继承可以继承内置对象。
:::

## 事件循环在浏览器和 `node` 中的区别
::: tip
浏览器中：

 - 执行所有`同步js代码` → 执行所有`微任务`→`渲染页面`→执行一个`宏任务`→执行宏任务产生的`微任务`→渲染页面→执行下一个`宏任务`→执行宏任务产生的`微任务`→循环……

node中：

- node10以前 
  - 执行一个阶段的所有任务→执行完`nextTick`队列里的任务→执行所有的`微任务`

- node11以后
  - 和浏览器做了统一
:::

## 模块化进程
>`IIFE`：最开始采用自执行函数形成私有作用域来编写模块化，避免变量冲突
>
>`AMD`：采用`requireJs`编写模块化，特点：必须提前进行声明
>
>`CMD`：采用`Sea.js`来编写模块化，特点：可以动态导入模块
>
>`CommonJS`：`nodeJS`中自带的模块化（`require`的导入方式）
>
>`UMD`：兼容`AMD`,`CommonJS`模块化语法；
>
>`ES6 Modules`：`ES6`引入的模块化，支持`import`导入另一个`JS`

## `DOCTYPE` 的作用
>告诉浏览器的解析器，用什么文档标准来解析文档。如果`DOCTYPE`不存在或者格式不正确，文档将以兼容模式呈现。

## 兼容模式和标准模式的区别
>标准模式的渲染方式和`JS`引擎的解析方式都以该浏览器最新的标准去运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防站点无法工作。

## 为什么HTML5不需要DTD？
>`DTD`的作用是用来定义文档中的规则。因为`HTML5`以前都是基于`SGML`的，所以需要通过制定`DTD`来制定文档的规则。而`HTML5`不是基于`SGML`的，所以不需要`DTD`；

## 前端性能优化
### 页面内容方面
::: tip 页面内容
- 1、使用`CSS`雪碧图、图片小于`1M`时，使用`base64`来减少`HTTP`请求，避免请求过多。
- 2、通过设置缓存策略，对常用不变的资源进行缓存
- 3、非必要资源采用延迟加载的方式来请求。
- 4、使用代码移除（`Tree-shaking`），作用域提升（`Scope hoisting`）和代码分割（`Code-splitting`）来减少有效负载；
:::
### 服务器方面
:::tip 服务器
- 1、使用`CDN`服务，来提高用户对于资源的请求速度
- 2、服务器开启`Gzip、Deflate`等方式对于传输的资源进行压缩，减小文件体积
- 3、尽可能减少`cookie`的大小，并且通过将静态资源分配到非主域名下，来避免请求静态资源时携带不必要的`Cookie`（也叫`cookie`隔离）
:::

## 精度丢失问题
::: tip 0.1 + 0.2 === 0.3
为什么0.1 + 0.2 === 0.3 在`JS`中运算结果为`false`?
`JS`使用`Number`类型表示数字（整数和浮点数），遵循 IEEE754 标准，适用64位固定长度来表示，也就是标准的double双精度浮点数，
 - 1  ：符号位，0表示正数，1表示负数
 - 11 ：指数位（e）
 - 52 : 尾数，小数点后面的部分（即有效数字）
这样的存储结构的好处在于可以统一的处理整数和小数，节省存储空间

在运算时， 十进制的 0.1 和 0.2 会被转换成二进制的双精度浮点数，转换后会无限循环。由于IEEE754 的尾数限制最多52位，需要将超出的部分截掉，截取采用0舍1入的原则。
```js
   0.00011001100110011001100110011001100110011001100110011010
  +0.00110011001100110011001100110011001100110011001100110100
  ------------------------------------------------------------
  =0.01001100110011001100110011001100110011001100110011001110
```
这样在进制的转换中，精度已经丢失，所以相加之后会出现偏差，这就是精度丢失的根本原因。再转换为二进制也就不为0.3了

解决方法：
 - 1、ES6在`Number`对象上新增了一个极小的常量 `Number.EPSILON`，可以用此常量为浮点数设置一个误差范围，只要误差小于`Number.EPSILON`，我们就可以认为结果是可靠的
 - 2、将小数放大为整数（乘10的N次方），然后进行算术运算，最后再缩小为小数(除法)
 - 3、使用第三方库如math.js、big.js
:::

## script标签的async和defer属性
::: tip async
（高程4解析）
`async(HTML5)`：异步执行脚本（只对外部脚本文件有效）
添加了`defer`属性的`script`外部脚本，表示立刻开始下载脚本，能够异步的加载脚本，而且不会阻塞页面的加载。但是一旦下载完成就会立刻执行，执行时会阻塞页面的加载，所以异步脚本不应该在加载期间修改`DOM`。而且很可能不会按照原本的顺序执行。
异步脚本保证会在页面`load`时间之前执行，但可能会在`DOMContentLoaded(DOM结构加载完成)`事件之前或之后执行。

情况一：`HTML`未解析完，`async`脚本已经加载完成，`HTML`停止解析，去执行脚本，脚本执行完毕后，`HTML`继续解析。`HTML`解析完成后触发`DOMContentLoaded`事件。
<img :src="$withBase('/assets/test-async1.png')" alt="test-async1">

情况二：`HTML`解析完成后，`async`脚本才加载完成，然后执行脚本。在`HTML`解析完成后就触发了`DOMContentLoaded`事件。
<img :src="$withBase('/assets/test-async2.png')" alt="test-async2">

**defer**

`defer(HTML4.01)`：推迟执行脚本（只对外部脚本文件有效）
遇到带有`defer`属性的`script`外部脚本，会立即下载，但是只会在浏览器解析到结束的`</html>`标签后才会按照顺序执行，并且都会在 `DOMContentLoaded`事件之前执行（实际不一定按照顺序执行或在`DOMContentLoaded(DOM结构加载完成)`事件之前执行，因此最好只包含一个这样的脚本）
这个属性表示脚本在执行的时候不会改变页面的结构。也就是说脚本会被延迟到文档完全被解析和显示后再执行。设置了`defer`属性，相当于告诉浏览器该脚本立即下载，但是延迟执行。

情况一：`HTML`未解析完，`defer`脚本已经加载完成，等待`HTML`解析完成后，去执行脚本，脚本执行完毕后触发`DOMContentLoaded`事件。
<img :src="$withBase('/assets/test-defer1.png')" alt="test-defer1">

情况二：`HTML`解析完成后，`defer`脚本才加载完成，然后执行脚本，脚本执行完毕后触发`DOMContentLoaded`事件。
<img :src="$withBase('/assets/test-defer2.png')" alt="test-defer2">

**`共同点：`**
- 1、下载脚本时不会阻塞页面的加载（执行时会）
- 2、只对外部脚本文件有效
- 3、都在`onload`事件之前
:::