---
title: 手写面试题
sidebarDepth: 0
---
[[toc]]
# 手写面试题

## 防抖和节流
### 防抖
>高频事件触发，但在n秒内只执行一次，n秒内再次触发则重新计时；
```js
function unshake(fn){
	let timer = null;
	return function(){
		clearTimeout(timer);
		timer = setTimeout(()=>{
			fn.apply(this,arguments);
			clearTimeout(timer);
		},500)
	}
}
```

### 节流
>高频事件触发时，n秒内只执行一次，所以节流会稀释函数的执行频率
```js
function throttle(fn){
	let canRun = true;
	return function(){
		if(!canRun) return;
		canRun = false;
		setTimeout(()=>{
			fn.apply(this,arguments);
			canRun = true;
		},500)
	}
}
```

## 深度克隆
```js
function deepClone(val,map = new WeakMap()){
	//如果传入的值是null或者是基本类型，则直接返回数值本身；
	if(val == null || typeof val !== 'object') return val;
  if(val instanceof Date) return new Date(ob)
	//如果克隆的值之前克隆过，则直接返回之前的值；
	if(map.has(val)) return map.get(val);
	//判断克隆的是数组还是对象
	let clone = Array.isArray(val) ? [] : {};
	//开始克隆并存储
	map.set(val,clone);
	let keys = Reflect.ownKeys(val);//返回对象的所有属性
	let len = keys.length;
	while(len--){
		clone[keys[len]] = deepClone(val[keys[len]],map);
	}
	return clone;
}
```

## 自己实现new方法
::: tip 思路
- 1、创建一个新对象，并把这个对象的`__proto__`属性指向传入fn的原型
- 2、把函数中的`this`指向创建的新对象，并让函数执行
- 3、函数执行返回的是否是对象，如果是则返回，如果不是则返回新建的对象；
```js
function _new(fn){
	let obj = Object.create(fn.prototype);
	let arg = [].slice.call(arguments,1);
	let res = fn.apply(obj,arg);
	return res instanceOf Object ? res : obj;
}
```
:::

## 手写bind
:::tip ES5版
```js 
Function.prototype._bind = function(ctx){
  ctx = ctx || window
  var fn = this
  var outerArgs = Array.prototype.slice.call(arguments,1)
  return function(){
    return fn.apply(ctx,outerArgs.concat(Array.prototype.slice.call(arguments)))
  }
}
```
:::

## 手写call
:::tip ES5版
```js 
Function.prototype._call = function(ctx){
  ctx = ctx || window
  ctx._thisFn = this
  var args = []
  for(var i = 1; i < arguments.length; i++){
    args.push('arguments[' + i + ']')
  }
  var res = eval('ctx._thisFn(' + args + ')')
  delete ctx._thisFn
  return res
}
```
:::

## 手写apply
:::tip ES5版
```js 
Function.prototype._apply = function(ctx, args){
  ctx = ctx || window
  ctx._thisFn = this
  args instanceof Array ? null : args = []
  var values = []
  for(var i = 0; i < args.length; i++){
    args.push('args[' + i + ']')
  }
  var res = eval('ctx._thisFn(' + values + ')')
  delete ctx._thisFn
  return res
}
```
:::

## instanceOf
::: tip
```js
function myInstanceOf(val, ClassA){
  const prototype = ClassA.prototype
  while(val = val.__proto__){
    if(val === prototype) return true
  }
  return false
}
```
:::

## 手写模板字符串实现
::: tip
```js
function fn(str){
  const reg = /\$\{([^}]*)\}/g
  str = str.replace(reg, function(k, expr){
    return eval(expr)
  })
  return str
}
```
:::

## 手写urlParams
::: tip
```js
function urlParams(url){
  const reg = /[?&]([^?=&]+)(?:=([^?=&]*))?/g
  const res = {}
  url.indexOf('#') > -1 ? url = url.replace('#','&hash=') : null
  url = url.replace(reg, function(k, group1,group2){
    res[group1] = group2
  })
  return res
}
```
:::

## 手写并发请求限制函数
```js
function fetchWithLimit(urls = [], limit){
  const res = []
  const count = 0
  const index = 0
  if(urls.length === 0) return res
  return new Promise((resolve,reject)=>{
    while(index < limit){
      _fetch(urls[index], index)
    }
    // TODO  index
    function _fetch(url, index){
      if(count >= urls.length) return resolve(res)
      if(!url){
        res[index++] = url
        _fetch(urls[index], index)
        return
      }
      fetch(url).then(data=>{
        count++
        res[index++] = { type: 'success', data }
        _fetch(urls[index], index)
      }).catch(err=>{
        count++
        res[index++] = { type: 'err', err }
        _fetch(urls[index], index)
      })
    }
  })
}
```
